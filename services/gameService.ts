import { supabase } from '../lib/supabase';
import { Game, PlatformType } from '../types';
import { CommunityGameStat } from './authService'; // We can reuse the type or move it

export const gameService = {
  // Fetch user's games
  fetchUserGames: async (userId: string): Promise<Game[]> => {
    const { data, error } = await supabase
      .from('games')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: true });

    if (error) {
      console.error('Error fetching games:', error);
      return [];
    }

    // Map DB fields (snake_case) to Frontend types (camelCase)
    return data.map((g: any) => ({
      id: g.id,
      name: g.name,
      platform: g.platform as PlatformType,
      category: g.category,
      imageUrl: g.image_url,
      isPlatinum: g.is_platinum,
      selected: false,
      isLoadingImage: false
    }));
  },

  // Add a new game
  addGame: async (userId: string, game: Game): Promise<boolean> => {
    const { error } = await supabase
      .from('games')
      .insert([{
        // id is auto-generated by DB if we omit it, but we can also pass the UUID generated by frontend
        // Let's rely on frontend UUID to keep UI optimistic update consistent
        id: game.id, 
        user_id: userId,
        name: game.name,
        platform: game.platform,
        category: game.category,
        image_url: game.imageUrl,
        is_platinum: game.isPlatinum
      }]);

    if (error) {
      console.error('Error adding game:', error);
      return false;
    }
    return true;
  },

  // Update a game (image, category, platinum)
  updateGame: async (gameId: string, updates: Partial<Game>): Promise<boolean> => {
    // Convert frontend keys to DB snake_case
    const dbUpdates: any = {};
    if (updates.name) dbUpdates.name = updates.name;
    if (updates.category) dbUpdates.category = updates.category;
    if (updates.imageUrl) dbUpdates.image_url = updates.imageUrl;
    if (updates.isPlatinum !== undefined) dbUpdates.is_platinum = updates.isPlatinum;

    const { error } = await supabase
      .from('games')
      .update(dbUpdates)
      .eq('id', gameId);

    if (error) {
      console.error('Error updating game:', error);
      return false;
    }
    return true;
  },

  // Delete games
  deleteGames: async (gameIds: string[]): Promise<boolean> => {
    const { error } = await supabase
      .from('games')
      .delete()
      .in('id', gameIds);

    if (error) {
      console.error('Error deleting games:', error);
      return false;
    }
    return true;
  },

  // Clear all data for user
  clearAllGames: async (userId: string): Promise<boolean> => {
    const { error } = await supabase
        .from('games')
        .delete()
        .eq('user_id', userId);
    
    return !error;
  },

  // Get community stats (Real SQL query)
  getCommunityStats: async (currentUserId?: string): Promise<CommunityGameStat[]> => {
    // We select name, platform, and username from profiles joined
    // Note: In a real complex app we'd use an SQL View or RPC. 
    // Here we fetch raw data and aggregate in JS to keep it simple without creating complex SQL views.
    
    const { data, error } = await supabase
      .from('games')
      .select(`
        name,
        platform,
        user_id,
        profiles (username)
      `)
      .neq('user_id', currentUserId || '00000000-0000-0000-0000-000000000000') // Exclude self
      .limit(500); // Limit sample size for performance

    if (error || !data) return [];

    const stats: Record<string, { count: number, platforms: Set<PlatformType>, latestPlayer: string }> = {};

    data.forEach((row: any) => {
      const name = row.name;
      const username = row.profiles?.username || 'Anonymous';
      
      if (!stats[name]) {
        stats[name] = { count: 0, platforms: new Set(), latestPlayer: username };
      }
      stats[name].count += 1;
      stats[name].platforms.add(row.platform as PlatformType);
      // Randomly update latest player to show variety
      if (Math.random() > 0.5) stats[name].latestPlayer = username;
    });

    return Object.entries(stats)
      .map(([name, data]) => ({
        name,
        count: data.count,
        platforms: Array.from(data.platforms),
        latestPlayer: data.latestPlayer
      }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 50);
  }
};
